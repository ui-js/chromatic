<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>Color Scale Explorer - OKLCh Interactive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu, Cantarell, "Helvetica Neue", sans-serif;
      padding: 40px;
      background: #f5f5f5;
      line-height: 1.6;
    }

    h1 {
      color: #333;
      margin-bottom: 30px;
      font-size: 2rem;
    }

    .color-scale-container {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.08);
    }

    .scale-title {
      font-size: 1.3rem;
      color: #444;
      margin-bottom: 20px;
      font-weight: 600;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-label {
      font-size: 0.9rem;
      color: #666;
      font-weight: 500;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .control-value {
      font-family: "SF Mono", Monaco, Consolas, monospace;
      color: #333;
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.85rem;
    }

    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      outline: none;
      appearance: none;
      -webkit-appearance: none;
      position: relative;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid #4CAF50;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 2;
    }

    input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: 2px solid #4CAF50;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 2;
    }

    .color-scale {
      display: flex;
      gap: 2px;
      margin-bottom: 20px;
      border-radius: 8px;
      overflow: hidden;
    }

    .color-chip {
      flex: 1;
      height: 80px;
      position: relative;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .color-chip:hover {
      transform: scale(1.05);
      z-index: 10;
    }

    .color-info {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 4px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      font-size: 0.7rem;
      font-family: "SF Mono", Monaco, Consolas, monospace;
      opacity: 0;
      transition: opacity 0.2s;
      text-align: center;
    }

    .color-chip:hover .color-info {
      opacity: 1;
    }

    .visualization-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }

    .chart {
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
    }

    .chart-title {
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 10px;
      text-align: center;
    }

    svg {
      width: 100%;
      height: 200px;
    }

    .preset-buttons {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .preset-btn {
      padding: 8px 16px;
      border: 2px solid #ddd;
      background: white;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: #4CAF50;
      background: #f0f8f0;
    }

    .preset-btn.active {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }

    .copy-btn {
      padding: 6px 12px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.8rem;
      font-family: "SF Mono", Monaco, Consolas, monospace;
      transition: all 0.2s;
      margin-left: auto;
    }

    .copy-btn:hover {
      background: #1976D2;
      transform: translateY(-1px);
    }

    .copy-btn.copied {
      background: #4CAF50;
    }
  </style>
</head>

<body>
  <h1>ðŸŽ¨ Interactive Color Scale Explorer</h1>

  <div style="margin-bottom: 20px; display: flex; gap: 10px;">
    <button id="shareBtn"
      style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
      ðŸ“‹ Copy Share Link
    </button>
    <button id="resetBtn"
      style="padding: 10px 20px; background: #f44336; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1rem;">
      ðŸ”„ Reset to Defaults
    </button>
  </div>

  <div id="app"></div>

  <script type="module">
    // Color conversion utilities
    function oklchToRgb(l, c, h) {
      // Convert OKLCh to OKLab
      const hRad = h * Math.PI / 180;
      const a = c * Math.cos(hRad);
      const b = c * Math.sin(hRad);

      // OKLab to linear RGB
      const l_ = l + 0.3963377774 * a + 0.2158037573 * b;
      const m_ = l - 0.1055613458 * a - 0.0638541728 * b;
      const s_ = l - 0.0894841775 * a - 1.2914855480 * b;

      const l3 = l_ * l_ * l_;
      const m3 = m_ * m_ * m_;
      const s3 = s_ * s_ * s_;

      let r = 4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3;
      let g = -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3;
      let b_ = -0.0041960863 * l3 - 0.7034186147 * m3 + 1.7076147010 * s3;

      // Apply gamma correction
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : 12.92 * g;
      b_ = b_ > 0.0031308 ? 1.055 * Math.pow(b_, 1 / 2.4) - 0.055 : 12.92 * b_;

      // Clamp to [0, 1]
      r = Math.max(0, Math.min(1, r));
      g = Math.max(0, Math.min(1, g));
      b_ = Math.max(0, Math.min(1, b_));

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b_ * 255)];
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function generateColorScale(baseL, baseC, baseH, steps = 11) {
      const colors = [];
      const midIndex = Math.floor(steps / 2);

      // Create lighter and darker anchor colors similar to the Chromatic implementation
      const lightColor = { l: Math.min(0.95, baseL + 0.35), c: baseC * 0.3, h: baseH };
      const darkColor = {
        l: Math.max(0.15, baseL - 0.45),
        c: baseC * 0.7,
        h: (baseH - 20 * Math.sin(4 * Math.PI * (baseH / 360)) + 360) % 360
      };

      for (let i = 0; i < steps; i++) {
        let l, c, h;

        if (i < midIndex) {
          // Lighter colors: interpolate from light anchor to base
          const t = (midIndex - i) / midIndex;
          const easedT = t * t * (3 - 2 * t); // Smoothstep easing
          l = baseL + (lightColor.l - baseL) * easedT;
          c = baseC + (lightColor.c - baseC) * easedT;
          h = baseH;
        } else if (i === midIndex) {
          // Base color
          l = baseL;
          c = baseC;
          h = baseH;
        } else {
          // Darker colors: interpolate from base to dark anchor
          const t = (i - midIndex) / (steps - midIndex - 1);
          const easedT = t * t * (3 - 2 * t); // Smoothstep easing
          l = baseL + (darkColor.l - baseL) * easedT;
          c = baseC + (darkColor.c - baseC) * easedT;
          h = baseH + (darkColor.h - baseH) * easedT * 0.3; // Gradual hue shift
        }

        const [r, g, b] = oklchToRgb(l, c, h);
        const hex = rgbToHex(r, g, b);

        colors.push({
          hex,
          l: l.toFixed(3),
          c: c.toFixed(3),
          h: h.toFixed(1),
          index: i * 100
        });
      }

      return colors;
    }

    // Presets
    const presets = [
      { name: 'Red', l: 0.65, c: 0.25, h: 25 },
      { name: 'Orange', l: 0.75, c: 0.20, h: 60 },
      { name: 'Yellow', l: 0.85, c: 0.18, h: 100 },
      { name: 'Green', l: 0.70, c: 0.22, h: 140 },
      { name: 'Cyan', l: 0.75, c: 0.15, h: 195 },
      { name: 'Blue', l: 0.60, c: 0.25, h: 260 },
      { name: 'Purple', l: 0.55, c: 0.28, h: 300 },
      { name: 'Pink', l: 0.70, c: 0.20, h: 350 },
      { name: 'Gray', l: 0.60, c: 0.02, h: 0 },
      { name: 'Brown', l: 0.45, c: 0.12, h: 45 }
    ];

    // Application
    class ColorScaleExplorer {
      constructor() {
        // Default scales
        this.defaultScales = [
          { id: 'scale1', name: 'Single Color', type: 'single', l: 0.60, c: 0.25, h: 260 },
          {
            id: 'scale2', name: 'Two Color Gradient', type: 'double',
            colors: [
              { l: 0.85, c: 0.15, h: 60 },  // Light yellow
              { l: 0.45, c: 0.25, h: 20 }   // Dark red-orange
            ]
          },
          {
            id: 'scale3', name: 'Three Color Gradient', type: 'triple',
            colors: [
              { l: 0.75, c: 0.20, h: 200 },  // Light cyan
              { l: 0.60, c: 0.25, h: 140 },  // Mid green
              { l: 0.35, c: 0.20, h: 60 }    // Dark yellow-orange
            ]
          }
        ];

        // Load scales from URL or use defaults
        this.scales = this.loadFromURL() || JSON.parse(JSON.stringify(this.defaultScales));
        this.init();
      }

      init() {
        this.render();
        this.attachEventListeners();
        // Set initial URL if not already set
        if (!window.location.search) {
          this.updateURL();
        }
      }

      loadFromURL() {
        const params = new URLSearchParams(window.location.search);
        const data = params.get('config');

        if (!data) return null;

        try {
          // Decode and parse the configuration
          const decoded = decodeURIComponent(data);
          const config = JSON.parse(decoded);

          // Validate the structure
          if (Array.isArray(config) && config.length === 3) {
            // Merge with default names and types
            return config.map((scale, idx) => ({
              ...this.defaultScales[idx],
              ...scale,
              id: this.defaultScales[idx].id,
              name: this.defaultScales[idx].name,
              type: this.defaultScales[idx].type
            }));
          }
        } catch (e) {
          console.error('Failed to parse URL configuration:', e);
        }

        return null;
      }

      updateURL() {
        // Create a minimal representation of the current state
        const config = this.scales.map(scale => {
          if (scale.type === 'single') {
            return {
              l: Number(scale.l.toFixed(3)),
              c: Number(scale.c.toFixed(3)),
              h: Number(scale.h.toFixed(1))
            };
          } else {
            return {
              colors: scale.colors.map(color => ({
                l: Number(color.l.toFixed(3)),
                c: Number(color.c.toFixed(3)),
                h: Number(color.h.toFixed(1))
              }))
            };
          }
        });

        // Encode as URL parameter
        const encoded = encodeURIComponent(JSON.stringify(config));
        const params = new URLSearchParams();
        params.set('config', encoded);

        // Update URL without triggering page reload
        const newURL = `${window.location.pathname}?${params.toString()}`;
        window.history.replaceState({}, '', newURL);
      }

      generateScaleFunction(scale) {
        if (scale.type === 'single') {
          // For single color: scale(oklch(l c h))
          const l = scale.l.toFixed(3);
          const c = scale.c.toFixed(3);
          const h = scale.h.toFixed(1);
          return `scale(oklch(${l} ${c} ${h}deg))`;
        } else if (scale.type === 'double') {
          // For two colors: scale(oklch(...), oklch(...))
          const color1 = scale.colors[0];
          const color2 = scale.colors[1];
          const l1 = color1.l.toFixed(3);
          const c1 = color1.c.toFixed(3);
          const h1 = color1.h.toFixed(1);
          const l2 = color2.l.toFixed(3);
          const c2 = color2.c.toFixed(3);
          const h2 = color2.h.toFixed(1);
          return `scale(oklch(${l1} ${c1} ${h1}deg), oklch(${l2} ${c2} ${h2}deg))`;
        } else if (scale.type === 'triple') {
          // For three colors: scale(oklch(...), oklch(...), oklch(...))
          const color1 = scale.colors[0];
          const color2 = scale.colors[1];
          const color3 = scale.colors[2];
          const l1 = color1.l.toFixed(3);
          const c1 = color1.c.toFixed(3);
          const h1 = color1.h.toFixed(1);
          const l2 = color2.l.toFixed(3);
          const c2 = color2.c.toFixed(3);
          const h2 = color2.h.toFixed(1);
          const l3 = color3.l.toFixed(3);
          const c3 = color3.c.toFixed(3);
          const h3 = color3.h.toFixed(1);
          return `scale(oklch(${l1} ${c1} ${h1}deg), oklch(${l2} ${c2} ${h2}deg), oklch(${l3} ${c3} ${h3}deg))`;
        }
      }

      render() {
        const app = document.getElementById('app');
        app.innerHTML = this.scales.map(scale => this.renderScale(scale)).join('');
      }

      renderScale(scale) {
        let colors;
        if (scale.type === 'single') {
          colors = generateColorScale(scale.l, scale.c, scale.h);
        } else if (scale.type === 'double') {
          colors = this.generateMultiColorScale(scale.colors[0], scale.colors[1]);
        } else if (scale.type === 'triple') {
          colors = this.generateMultiColorScale(scale.colors[0], scale.colors[1], scale.colors[2]);
        }

        return `
          <div class="color-scale-container" data-scale-id="${scale.id}" data-scale-type="${scale.type}">
            <div style="display: flex; align-items: center; margin-bottom: 20px;">
              <h2 class="scale-title" style="margin: 0;">${scale.name}</h2>
              <button class="copy-btn" data-scale-id="${scale.id}">
                ðŸ“‹ Copy scale()
              </button>
            </div>
            
            ${scale.type === 'single' ? `
            <div class="preset-buttons">
              ${presets.map(preset => `
                <button class="preset-btn" data-preset='${JSON.stringify(preset)}'>
                  ${preset.name}
                </button>
              `).join('')}
            </div>
            
            <div class="controls">
              <div class="control-group">
                <label class="control-label">
                  Lightness (L)
                  <span class="control-value">${(scale.l * 100).toFixed(1)}%</span>
                </label>
                <input type="range" 
                  class="lightness-slider" 
                  data-param="l" 
                  min="0" 
                  max="1" 
                  step="0.01" 
                  value="${scale.l}"
                  style="background: linear-gradient(to right, #000 0%, #fff 100%);">
              </div>
              
              <div class="control-group">
                <label class="control-label">
                  Chroma (C)
                  <span class="control-value">${scale.c.toFixed(3)}</span>
                </label>
                <input type="range" 
                  class="chroma-slider" 
                  data-param="c" 
                  min="0" 
                  max="0.4" 
                  step="0.01" 
                  value="${scale.c}"
                  style="background: linear-gradient(to right, 
                    ${rgbToHex(...oklchToRgb(scale.l, 0, scale.h))} 0%, 
                    ${rgbToHex(...oklchToRgb(scale.l, 0.4, scale.h))} 100%);">
              </div>
              
              <div class="control-group">
                <label class="control-label">
                  Hue (H)
                  <span class="control-value">${scale.h.toFixed(1)}Â°</span>
                </label>
                <input type="range" 
                  class="hue-slider" 
                  data-param="h" 
                  min="0" 
                  max="360" 
                  step="1" 
                  value="${scale.h}"
                  style="background: linear-gradient(to right, 
                    ${Array.from({ length: 13 }, (_, i) => {
          const h = i * 30;
          return `${rgbToHex(...oklchToRgb(scale.l, scale.c, h))} ${(i / 12 * 100).toFixed(1)}%`;
        }).join(', ')});">
              </div>
            </div>
            ` : scale.type === 'double' ? `
            <div class="controls" style="display: flex; gap: 20px;">
              ${scale.colors.map((color, idx) => `
              <div style="flex: 1; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                <h4 style="margin: 0 0 15px 0; color: #666; font-size: 0.95rem; font-weight: 600;">Color ${idx + 1}</h4>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                  <div class="control-group">
                    <label class="control-label">
                      Lightness (L)
                      <span class="control-value">${(color.l * 100).toFixed(1)}%</span>
                    </label>
                    <input type="range" 
                      class="lightness-slider" 
                      data-color-index="${idx}"
                      data-param="l" 
                      min="0" 
                      max="1" 
                      step="0.01" 
                      value="${color.l}"
                      style="background: linear-gradient(to right, #000 0%, #fff 100%);">
                  </div>
                  
                  <div class="control-group">
                    <label class="control-label">
                      Chroma (C)
                      <span class="control-value">${color.c.toFixed(3)}</span>
                    </label>
                    <input type="range" 
                      class="chroma-slider" 
                      data-color-index="${idx}"
                      data-param="c" 
                      min="0" 
                      max="0.4" 
                      step="0.01" 
                      value="${color.c}"
                      style="background: linear-gradient(to right, 
                        ${rgbToHex(...oklchToRgb(color.l, 0, color.h))} 0%, 
                        ${rgbToHex(...oklchToRgb(color.l, 0.4, color.h))} 100%);">
                  </div>
                  
                  <div class="control-group">
                    <label class="control-label">
                      Hue (H)
                      <span class="control-value">${color.h.toFixed(1)}Â°</span>
                    </label>
                    <input type="range" 
                      class="hue-slider" 
                      data-color-index="${idx}"
                      data-param="h" 
                      min="0" 
                      max="360" 
                      step="1" 
                      value="${color.h}"
                      style="background: linear-gradient(to right, 
                        ${Array.from({ length: 13 }, (_, i) => {
          const h = i * 30;
          return `${rgbToHex(...oklchToRgb(color.l, color.c, h))} ${(i / 12 * 100).toFixed(1)}%`;
        }).join(', ')});">
                  </div>
                </div>
              </div>
              `).join('')}
            </div>
            ` : `
            <div class="controls" style="display: flex; gap: 20px;">
              ${scale.colors.map((color, idx) => `
              <div style="flex: 1; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px;">
                <h4 style="margin: 0 0 15px 0; color: #666; font-size: 0.95rem; font-weight: 600;">Color ${idx + 1}</h4>
                <div style="display: flex; flex-direction: column; gap: 15px;">
                  <div class="control-group">
                    <label class="control-label">
                      Lightness (L)
                      <span class="control-value">${(color.l * 100).toFixed(1)}%</span>
                    </label>
                    <input type="range" 
                      class="lightness-slider" 
                      data-color-index="${idx}"
                      data-param="l" 
                      min="0" 
                      max="1" 
                      step="0.01" 
                      value="${color.l}"
                      style="background: linear-gradient(to right, #000 0%, #fff 100%);">
                  </div>
                  
                  <div class="control-group">
                    <label class="control-label">
                      Chroma (C)
                      <span class="control-value">${color.c.toFixed(3)}</span>
                    </label>
                    <input type="range" 
                      class="chroma-slider" 
                      data-color-index="${idx}"
                      data-param="c" 
                      min="0" 
                      max="0.4" 
                      step="0.01" 
                      value="${color.c}"
                      style="background: linear-gradient(to right, 
                        ${rgbToHex(...oklchToRgb(color.l, 0, color.h))} 0%, 
                        ${rgbToHex(...oklchToRgb(color.l, 0.4, color.h))} 100%);">
                  </div>
                  
                  <div class="control-group">
                    <label class="control-label">
                      Hue (H)
                      <span class="control-value">${color.h.toFixed(1)}Â°</span>
                    </label>
                    <input type="range" 
                      class="hue-slider" 
                      data-color-index="${idx}"
                      data-param="h" 
                      min="0" 
                      max="360" 
                      step="1" 
                      value="${color.h}"
                      style="background: linear-gradient(to right, 
                        ${Array.from({ length: 13 }, (_, i) => {
          const h = i * 30;
          return `${rgbToHex(...oklchToRgb(color.l, color.c, h))} ${(i / 12 * 100).toFixed(1)}%`;
        }).join(', ')});">
                  </div>
                </div>
              </div>
              `).join('')}
            </div>
            `}
            
            <div class="color-scale">
              ${colors.map(color => `
                <div class="color-chip" style="background: ${color.hex}">
                  <div class="color-info">
                    ${color.index}<br>
                    ${color.hex}<br>
                    L:${color.l} C:${color.c}
                  </div>
                </div>
              `).join('')}
            </div>
            
            <div class="visualization-container">
              <div class="chart">
                <div class="chart-title">Lightness Distribution</div>
                <svg class="lightness-chart" viewBox="0 0 400 200" preserveAspectRatio="xMidYMid meet">
                  <defs>
                    <linearGradient id="grid-${scale.id}" x1="0%" y1="0%" x2="0%" y2="100%">
                      <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
                      <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
                    </linearGradient>
                  </defs>
                  <rect width="100%" height="100%" fill="url(#grid-${scale.id})" />
                  ${this.renderLightnessChart(colors)}
                </svg>
              </div>
              
              <div class="chart">
                <div class="chart-title">Chroma/Hue Plot</div>
                <svg class="chroma-chart" viewBox="0 0 400 200" preserveAspectRatio="xMidYMid meet">
                  <rect width="100%" height="100%" fill="#fafafa" />
                  ${this.renderChromaChart(colors)}
                </svg>
              </div>
            </div>
          </div>
        `;
      }

      renderLightnessChart(colors) {
        const width = 400;
        const height = 200;
        const padding = 20;
        const chartWidth = width - 2 * padding;
        const chartHeight = height - 2 * padding;

        // Create path
        const points = colors.map((color, i) => {
          const x = padding + (i / (colors.length - 1)) * chartWidth;
          const y = height - padding - (parseFloat(color.l) * chartHeight);
          return `${x},${y}`;
        });

        // Grid lines
        let gridLines = '';
        for (let i = 0; i <= 10; i++) {
          const y = padding + (i / 10) * chartHeight;
          gridLines += `<line x1="${padding}" y1="${y}" x2="${width - padding}" y2="${y}" stroke="#e0e0e0" stroke-width="0.5" />`;
        }

        // Value labels
        let labels = '';
        for (let i = 0; i <= 10; i += 2) {
          const y = height - padding - (i / 10) * chartHeight;
          labels += `<text x="10" y="${y + 3}" font-size="10" fill="#999">${(i / 10).toFixed(1)}</text>`;
        }

        return `
          ${gridLines}
          ${labels}
          <polyline points="${points.join(' ')}" fill="none" stroke="#4CAF50" stroke-width="2" />
          ${colors.map((color, i) => {
          const x = padding + (i / (colors.length - 1)) * chartWidth;
          const y = height - padding - (parseFloat(color.l) * chartHeight);
          return `<circle cx="${x}" cy="${y}" r="4" fill="${color.hex}" stroke="white" stroke-width="2" />`;
        }).join('')}
        `;
      }

      renderChromaChart(colors) {
        const width = 400;
        const height = 200;
        const centerX = width / 2;
        const centerY = height / 2;
        const maxRadius = 80;

        // Grid circles
        let gridCircles = '';
        for (let i = 1; i <= 4; i++) {
          const r = (i / 4) * maxRadius;
          gridCircles += `<circle cx="${centerX}" cy="${centerY}" r="${r}" fill="none" stroke="#e0e0e0" stroke-width="0.5" />`;
        }

        // Axis lines and hue markers
        let axes = `
          <line x1="${centerX}" y1="${centerY - maxRadius}" x2="${centerX}" y2="${centerY + maxRadius}" stroke="#e0e0e0" stroke-width="0.5" />
          <line x1="${centerX - maxRadius}" y1="${centerY}" x2="${centerX + maxRadius}" y2="${centerY}" stroke="#e0e0e0" stroke-width="0.5" />
        `;

        // Add hue markers at 0Â°, 90Â°, 180Â°, 270Â°
        const hueMarkers = [
          { deg: 0, label: '0Â°' },
          { deg: 90, label: '90Â°' },
          { deg: 180, label: '180Â°' },
          { deg: 270, label: '270Â°' }
        ];

        hueMarkers.forEach(marker => {
          const angle = (marker.deg - 90) * Math.PI / 180;
          const x = centerX + (maxRadius + 5) * Math.cos(angle);
          const y = centerY + (maxRadius + 5) * Math.sin(angle);
          axes += `<text x="${x}" y="${y + 3}" font-size="8" fill="#999" text-anchor="middle">${marker.label}</text>`;
        });

        // Plot points
        const points = colors.map((color, i) => {
          // Convert hue to radians, with 0Â° at top (12 o'clock)
          const angle = (parseFloat(color.h) - 90) * Math.PI / 180;
          const radius = parseFloat(color.c) * maxRadius / 0.4;
          const x = centerX + radius * Math.cos(angle);
          const y = centerY + radius * Math.sin(angle);
          return { x, y, hex: color.hex, hue: parseFloat(color.h) };
        });

        // Path
        const pathPoints = points.map(p => `${p.x},${p.y}`).join(' ');

        return `
          ${gridCircles}
          ${axes}
          <polyline points="${pathPoints}" fill="none" stroke="#2196F3" stroke-width="2" />
          ${points.map(p => `
            <circle cx="${p.x}" cy="${p.y}" r="4" fill="${p.hex}" stroke="white" stroke-width="2" />
          `).join('')}
        `;
      }

      generateMultiColorScale(...colors) {
        // Simulate the scale() function behavior with more natural interpolation
        const steps = 11;
        const result = [];

        if (colors.length === 2) {
          // Two-color gradient with more natural easing
          for (let i = 0; i < steps; i++) {
            // Use a slight easing curve instead of pure linear
            let t = i / (steps - 1);
            t = t * t * (3 - 2 * t); // Smoothstep easing

            const l = colors[0].l + (colors[1].l - colors[0].l) * t;
            const c = colors[0].c + (colors[1].c - colors[0].c) * t;

            // Handle hue interpolation (shortest path)
            let h1 = colors[0].h;
            let h2 = colors[1].h;
            let hDiff = h2 - h1;
            if (hDiff > 180) hDiff -= 360;
            if (hDiff < -180) hDiff += 360;
            const h = (h1 + hDiff * t + 360) % 360;

            const [r, g, b] = oklchToRgb(l, c, h);
            const hex = rgbToHex(r, g, b);

            result.push({
              hex,
              l: l.toFixed(3),
              c: c.toFixed(3),
              h: h.toFixed(1),
              index: i * 100
            });
          }
        } else if (colors.length === 3) {
          // Three-color gradient with better distribution
          for (let i = 0; i < steps; i++) {
            let l, c, h;
            const t = i / (steps - 1);

            if (t <= 0.5) {
              // First half: interpolate from color 1 to color 2
              const localT = t * 2;
              const easedT = localT * localT * (3 - 2 * localT); // Smoothstep

              l = colors[0].l + (colors[1].l - colors[0].l) * easedT;
              c = colors[0].c + (colors[1].c - colors[0].c) * easedT;

              let h1 = colors[0].h;
              let h2 = colors[1].h;
              let hDiff = h2 - h1;
              if (hDiff > 180) hDiff -= 360;
              if (hDiff < -180) hDiff += 360;
              h = (h1 + hDiff * easedT + 360) % 360;
            } else {
              // Second half: interpolate from color 2 to color 3
              const localT = (t - 0.5) * 2;
              const easedT = localT * localT * (3 - 2 * localT); // Smoothstep

              l = colors[1].l + (colors[2].l - colors[1].l) * easedT;
              c = colors[1].c + (colors[2].c - colors[1].c) * easedT;

              let h1 = colors[1].h;
              let h2 = colors[2].h;
              let hDiff = h2 - h1;
              if (hDiff > 180) hDiff -= 360;
              if (hDiff < -180) hDiff += 360;
              h = (h1 + hDiff * easedT + 360) % 360;
            }

            const [r, g, b] = oklchToRgb(l, c, h);
            const hex = rgbToHex(r, g, b);

            result.push({
              hex,
              l: l.toFixed(3),
              c: c.toFixed(3),
              h: h.toFixed(1),
              index: i * 100
            });
          }
        }

        return result;
      }

      attachEventListeners() {
        // Share button
        document.getElementById('shareBtn').addEventListener('click', () => {
          const url = window.location.href;
          navigator.clipboard.writeText(url).then(() => {
            const btn = document.getElementById('shareBtn');
            const originalText = btn.textContent;
            btn.textContent = 'âœ… Copied!';
            btn.style.background = '#4CAF50';
            setTimeout(() => {
              btn.textContent = originalText;
            }, 2000);
          }).catch(err => {
            console.error('Failed to copy URL:', err);
            alert('Failed to copy URL. Please copy it manually from the address bar.');
          });
        });

        // Reset button
        document.getElementById('resetBtn').addEventListener('click', () => {
          if (confirm('Reset all color scales to default values?')) {
            this.scales = JSON.parse(JSON.stringify(this.defaultScales));
            this.render();
            this.attachEventListeners();
            this.updateURL();
          }
        });

        // Copy buttons
        document.querySelectorAll('.copy-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const scaleId = e.target.dataset.scaleId;
            const scale = this.scales.find(s => s.id === scaleId);
            const scaleFunction = this.generateScaleFunction(scale);

            navigator.clipboard.writeText(scaleFunction).then(() => {
              const originalText = e.target.textContent;
              e.target.textContent = 'âœ… Copied!';
              e.target.classList.add('copied');
              setTimeout(() => {
                e.target.textContent = originalText;
                e.target.classList.remove('copied');
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy function:', err);
              alert('Failed to copy. Please copy manually:\n\n' + scaleFunction);
            });
          });
        });

        // Slider events
        document.querySelectorAll('input[type="range"]').forEach(slider => {
          slider.addEventListener('input', (e) => {
            const container = e.target.closest('.color-scale-container');
            const scaleId = container.dataset.scaleId;
            const scaleType = container.dataset.scaleType;
            const param = e.target.dataset.param;
            const value = parseFloat(e.target.value);

            // Update scale
            const scale = this.scales.find(s => s.id === scaleId);

            if (scaleType === 'single') {
              scale[param] = value;
            } else {
              const colorIndex = parseInt(e.target.dataset.colorIndex);
              scale.colors[colorIndex][param] = value;
            }

            // Update display
            const label = e.target.previousElementSibling;
            const valueSpan = label.querySelector('.control-value');
            if (param === 'h') {
              valueSpan.textContent = `${value.toFixed(1)}Â°`;
            } else if (param === 'l') {
              valueSpan.textContent = `${(value * 100).toFixed(1)}%`;
            } else {
              valueSpan.textContent = value.toFixed(3);
            }

            // Update slider gradients if needed
            if (scaleType === 'single') {
              this.updateSliderGradients(container, scale);
            } else {
              this.updateMultiSliderGradients(container, scale);
            }

            // Regenerate color scale
            this.updateColorScale(scaleId);

            // Update URL with new values
            this.updateURL();
          });
        });

        // Preset buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const container = e.target.closest('.color-scale-container');
            const scaleId = container.dataset.scaleId;
            const scaleType = container.dataset.scaleType;
            const preset = JSON.parse(e.target.dataset.preset);

            // Update scale
            const scale = this.scales.find(s => s.id === scaleId);
            Object.assign(scale, { l: preset.l, c: preset.c, h: preset.h });

            // Update sliders
            container.querySelector('[data-param="l"]').value = preset.l;
            container.querySelector('[data-param="c"]').value = preset.c;
            container.querySelector('[data-param="h"]').value = preset.h;

            // Update labels
            container.querySelector('[data-param="l"]').previousElementSibling.querySelector('.control-value').textContent = `${(preset.l * 100).toFixed(1)}%`;
            container.querySelector('[data-param="c"]').previousElementSibling.querySelector('.control-value').textContent = preset.c.toFixed(3);
            container.querySelector('[data-param="h"]').previousElementSibling.querySelector('.control-value').textContent = `${preset.h.toFixed(1)}Â°`;

            // Highlight active preset
            container.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
            e.target.classList.add('active');

            // Update slider gradients if needed
            if (scaleType === 'single') {
              this.updateSliderGradients(container, scale);
            } else {
              this.updateMultiSliderGradients(container, scale);
            }

            // Regenerate color scale
            this.updateColorScale(scaleId);

            // Update URL with new values
            this.updateURL();
          });
        });
      }

      updateSliderGradients(container, scale) {
        // Update chroma slider gradient
        const chromaSlider = container.querySelector('[data-param="c"]');
        if (chromaSlider) {
          chromaSlider.style.background = `linear-gradient(to right, 
            ${rgbToHex(...oklchToRgb(scale.l, 0, scale.h))} 0%, 
            ${rgbToHex(...oklchToRgb(scale.l, 0.4, scale.h))} 100%)`;
        }

        // Update hue slider gradient
        const hueSlider = container.querySelector('[data-param="h"]');
        if (hueSlider) {
          const gradientStops = Array.from({ length: 13 }, (_, i) => {
            const h = i * 30;
            return `${rgbToHex(...oklchToRgb(scale.l, scale.c, h))} ${(i / 12 * 100).toFixed(1)}%`;
          }).join(', ');
          hueSlider.style.background = `linear-gradient(to right, ${gradientStops})`;
        }
      }

      updateMultiSliderGradients(container, scale) {
        scale.colors.forEach((color, idx) => {
          // Update chroma slider gradient
          const chromaSlider = container.querySelector(`[data-color-index="${idx}"][data-param="c"]`);
          if (chromaSlider) {
            chromaSlider.style.background = `linear-gradient(to right, 
              ${rgbToHex(...oklchToRgb(color.l, 0, color.h))} 0%, 
              ${rgbToHex(...oklchToRgb(color.l, 0.4, color.h))} 100%)`;
          }

          // Update hue slider gradient  
          const hueSlider = container.querySelector(`[data-color-index="${idx}"][data-param="h"]`);
          if (hueSlider) {
            const gradientStops = Array.from({ length: 13 }, (_, i) => {
              const h = i * 30;
              return `${rgbToHex(...oklchToRgb(color.l, color.c, h))} ${(i / 12 * 100).toFixed(1)}%`;
            }).join(', ');
            hueSlider.style.background = `linear-gradient(to right, ${gradientStops})`;
          }
        });
      }

      updateColorScale(scaleId) {
        const scale = this.scales.find(s => s.id === scaleId);
        let colors;

        if (scale.type === 'single') {
          colors = generateColorScale(scale.l, scale.c, scale.h);
        } else if (scale.type === 'double') {
          colors = this.generateMultiColorScale(scale.colors[0], scale.colors[1]);
        } else if (scale.type === 'triple') {
          colors = this.generateMultiColorScale(scale.colors[0], scale.colors[1], scale.colors[2]);
        }

        const container = document.querySelector(`[data-scale-id="${scaleId}"]`);

        // Update color chips
        const colorScale = container.querySelector('.color-scale');
        colorScale.innerHTML = colors.map(color => `
          <div class="color-chip" style="background: ${color.hex}">
            <div class="color-info">
              ${color.index}<br>
              ${color.hex}<br>
              L:${color.l} C:${color.c}
            </div>
          </div>
        `).join('');

        // Update charts - set viewBox on SVG elements, not innerHTML
        const lightnessChart = container.querySelector('.lightness-chart');
        lightnessChart.setAttribute('viewBox', '0 0 400 200');
        lightnessChart.innerHTML = `
          <defs>
            <linearGradient id="grid-${scaleId}" x1="0%" y1="0%" x2="0%" y2="100%">
              <stop offset="0%" style="stop-color:#f0f0f0;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#ffffff;stop-opacity:1" />
            </linearGradient>
          </defs>
          <rect width="100%" height="100%" fill="url(#grid-${scaleId})" />
          ${this.renderLightnessChart(colors)}
        `;

        const chromaChart = container.querySelector('.chroma-chart');
        chromaChart.setAttribute('viewBox', '0 0 400 200');
        chromaChart.innerHTML = `
          <rect width="100%" height="100%" fill="#fafafa" />
          ${this.renderChromaChart(colors)}
        `;
      }
    }

    // Initialize app
    new ColorScaleExplorer();
  </script>
</body>

</html>